# 26-02-09
```glsl
float hash3D(vec3 p){
	return fract(sin(dot(p,vec3(127.1,311.7,74.7)))*43758.5453);
}

float valueNoise3D(vec3 p){
	// Get Cell and position in cell
	vec3 i = floor(p);
	vec3 f = fract(p);
	// smooth interpolation curve
	vec3 u = f *f *(3.0-2.0*f);

	// Get random values at all 8 corners of the cube
	float c000 = hash3D(i + vec3(0, 0, 0));  // front-bottom-left
    float c100 = hash3D(i + vec3(1, 0, 0));  // front-bottom-right
    float c010 = hash3D(i + vec3(0, 1, 0));  // front-top-left
    float c110 = hash3D(i + vec3(1, 1, 0));  // front-top-right
    float c001 = hash3D(i + vec3(0, 0, 1));  // back-bottom-left
    float c101 = hash3D(i + vec3(1, 0, 1));  // back-bottom-right
    float c011 = hash3D(i + vec3(0, 1, 1));  // back-top-left
    float c111 = hash3D(i + vec3(1, 1, 1));  // back-top-right

	// Interpolate along x (4 pairs of corners)
	float c00 = mix(c000,c100,u.x);
	float c10 = mix(c010,c110,u.x);
	float c01 = mix(c001,c101,u.x);
	float c11 = mix(c011,c111,u.x);

	//Interpolate along y ( 2 pairs of edges)
	float c0 = mix(c00,c10,u.y);
	float c1 = mix(c01,c11,u.y);

	//Interpoalte along z
	return mix(c0,c1,u.z);
}

float fbm3D(vec3 p, int octaves, float lacunarity, float gain){
	float value = 0.0;
	float amplitude = 0.5;
	float frequency = 1.0;

	for (int i = 0; i < 8; i++) {
    if (i < octaves) {
        value += valueNoise3D(p * frequency) * amplitude;
        frequency *= lacunarity;
        amplitude *= gain;
    }
}

	return value;
}

void main(){
	vec2 uv = gl_FragCoord.xy/u_resolution;
	uv.x *= u_resolution.x/u_resolution.y;
    
	float n = step(0.396,fbm3D(vec3(uv*4.0,u_time),4,2.0,0.35));
    float n1 = step(0.412,fbm3D(vec3(uv*4.0,u_time+0.1),5,2.0,0.35));
    float n2 = step(0.412,fbm3D(vec3(uv*4.0,u_time+0.4),5,2.4,0.25));
    
	vec3 color = vec3(n,n1,n2);
	gl_FragColor = vec4(color,1.0);
}
```